y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=Z_list$dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
setup$Z
View(setup)
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
model_dim <- dim(model_mat)
# Return a list containing the matrix and its dimensions
list(
matrix = model_mat,
dimensions = model_dim
)
})
browser()
Z <- do.call(cbind, Z_list['model_mat'])
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=Z_list$dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
Z_list
Z_list$model_mat
Z_list$matrix
names(Z_list)
Z_list[1]
Z_list[1,1]
Z_list[2]
Z_list[[1]]
Z_list[[2]]
Z_list[[1]]
dim(Z_list)
length(Z_list)
quit()
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
browser()
Z <- do.call(cbind, Z_list['model_mat'])
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=Z_list$dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
Z_list
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
browser()
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=Z_list$dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
View(Z)
dimensions
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
setup$Z
dim(setup$Z)
setup$dimensions
rep(c(1,2), setup$dimensions)
diag(rep(c(1,2), setup$dimensions), 24, 24)
rm(list = ls())
# Load necessary libraries
library(debug)
library(nlme)
library(lme4)
library(MASS)
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
solve_chol <- function(L, b) {
return (backsolve(L, forwardsolve(t(L),b)))
}
LMMprof <- function(theta, setup) {
# browser()
X <- setup$X
Z <- setup$Z
y <- setup$y
Z_cols<-setup$dimensions
# QR Decomposition of Z
qr_decomp <- qr(Z)
Q <- qr.Q(qr_decomp, complete = TRUE)
R <- qr.R(qr_decomp)
# Dimensions
n <- length(y)
p <- ncol(Z)
# Extract sigma and random effects variances from theta
sigma <- exp(theta[1])#I think we don't need to expone
psi_diag <- exp(2 * theta[-1])
# browser()
# Construct the covariance matrix Psi_b for the random effects
Psi_b <- diag(rep(psi_diag, Z_cols), ncol(Z), ncol(Z))
small_block<-R%*%Psi_b%*%t(R)+diag(1, nrow = p, ncol = p)*(sigma^2)
# Cholesky decomposition
small_block_chol <- chol(small_block)
small_block_Inv<-solve_chol(small_block_chol, diag(x = 1, nrow = p, ncol = p))
I_n_p <- diag(n - p)/(sigma^(2))
# Construct the full W matrix
W_middle <- rbind(
cbind(small_block_Inv, matrix(0, nrow = p, ncol = n - p)),
cbind(matrix(0, nrow = n - p, ncol = p), I_n_p)
)
# Calculate W using Q and the block matrix
# W3 <- qr.qy(qr_decomp, t(qr.qy(qr_decomp, t(W_middle))))
# W2<-Q %*% W_middle %*% t(Q)
# Compute log likelihood terms
XWX<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, X)
XWy<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, y)
XWX_chol <- chol(XWX)
beta_hat<-solve_chol(L=XWX_chol, b=XWy)
residual <- y - X %*% beta_hat
minus_log_likelihood<- 0.5*t(residual)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, residual)+sum(log(diag(small_block_Inv)))+ ((n - p) * log(sigma^2)/2)
# log_likelihood <- -0.5 * (t(residual) %*% W %*% residual + sum(log(diag(chol(small_block)))) + (n - p) * log(sigma^2))
print("minus_Log-likelihood:")
print(minus_log_likelihood)
attr(minus_log_likelihood, "beta_hat") <- beta_hat
return(minus_log_likelihood)  # Return negative log-likelihood for minimization
}
lmm <- function(form, dat, ref = list()) {
# Step 1: Setup model matrices and data
setup <- LMMsetup(form, dat, ref)
# Step 2: Initial guesses for theta: log(sigma) and log standard deviations for random effects
theta_init <- rep(0, length(ref) + 1)  # Starting with a small positive value
lower_bounds <- rep(log(.001)/2, length(ref) + 1)  # Example: ensuring all theta > -2
upper_bounds <- rep(Inf, length(ref) + 1)  # No upper bounds, or set specifically if needed
# Step 3: Optimize negative log-likelihood using `optim`
# opt <- optim(theta_init, LMMprof, setup = setup, method = "L-BFGS-B", control = list(fnscale = 1))
opt <- optim(theta_init, LMMprof, setup = setup, lower = lower_bounds,
upper = upper_bounds, method = "L-BFGS-B", control = list())
# Extract optimal theta and compute beta estimate
theta_opt <- opt$par
sigma_opt <- exp(theta_opt[1])
psi_diag_opt <- exp(2 * theta_opt[-1])
# # Recompute beta estimate using optimized theta
# #fix this one hac
# W <- chol2inv(chol(qr.R(qr(setup$Z)) %*% diag(psi_diag_opt, ncol(setup$Z), ncol(setup$Z)) %*% t(qr.R(qr(setup$Z))) + sigma_opt^2 * diag(length(setup$y))))
# beta_hat <- solve(t(setup$X) %*% W %*% setup$X, t(setup$X) %*% W %*% setup$y)
return(list(beta = beta_hat, theta = theta_opt))
}
mtrace(lmm, FALSE)
mtrace(LMMprof)
# Load the Machines dataset and use `lmm` function
data("Machines", package = "nlme")
result <- lmm(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
# mtrace(lmm, FALSE)
mtrace(LMMprof, FALSE)
# Load necessary libraries
library(debug)
library(nlme)
library(lme4)
library(MASS)
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
solve_chol <- function(L, b) {
return (backsolve(L, forwardsolve(t(L),b)))
}
LMMprof <- function(theta, setup) {
# browser()
X <- setup$X
Z <- setup$Z
y <- setup$y
Z_cols<-setup$dimensions
# QR Decomposition of Z
qr_decomp <- qr(Z)
Q <- qr.Q(qr_decomp, complete = TRUE)
R <- qr.R(qr_decomp)
# Dimensions
n <- length(y)
p <- ncol(Z)
# Extract sigma and random effects variances from theta
sigma <- exp(theta[1])#I think we don't need to expone
psi_diag <- exp(2 * theta[-1])
# browser()
# Construct the covariance matrix Psi_b for the random effects
Psi_b <- diag(rep(psi_diag, Z_cols), ncol(Z), ncol(Z))
small_block<-R%*%Psi_b%*%t(R)+diag(1, nrow = p, ncol = p)*(sigma^2)
# Cholesky decomposition
small_block_chol <- chol(small_block)
small_block_Inv<-solve_chol(small_block_chol, diag(x = 1, nrow = p, ncol = p))
I_n_p <- diag(n - p)/(sigma^(2))
# Construct the full W matrix
W_middle <- rbind(
cbind(small_block_Inv, matrix(0, nrow = p, ncol = n - p)),
cbind(matrix(0, nrow = n - p, ncol = p), I_n_p)
)
# Calculate W using Q and the block matrix
# W3 <- qr.qy(qr_decomp, t(qr.qy(qr_decomp, t(W_middle))))
# W2<-Q %*% W_middle %*% t(Q)
# Compute log likelihood terms
XWX<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, X)
XWy<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, y)
XWX_chol <- chol(XWX)
beta_hat<-solve_chol(L=XWX_chol, b=XWy)
residual <- y - X %*% beta_hat
minus_log_likelihood<- 0.5*t(residual)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, residual)+sum(log(diag(small_block_Inv)))+ ((n - p) * log(sigma^2)/2)
# log_likelihood <- -0.5 * (t(residual) %*% W %*% residual + sum(log(diag(chol(small_block)))) + (n - p) * log(sigma^2))
print("minus_Log-likelihood:")
print(minus_log_likelihood)
attr(minus_log_likelihood, "beta_hat") <- beta_hat
return(minus_log_likelihood)  # Return negative log-likelihood for minimization
}
lmm <- function(form, dat, ref = list()) {
# Step 1: Setup model matrices and data
setup <- LMMsetup(form, dat, ref)
# Step 2: Initial guesses for theta: log(sigma) and log standard deviations for random effects
theta_init <- rep(0, length(ref) + 1)  # Starting with a small positive value
lower_bounds <- rep(log(0.001), length(ref) + 1)  # Example: ensuring all theta > -2
upper_bounds <- rep(log(10), length(ref) + 1)  # No upper bounds, or set specifically if needed
# Step 3: Optimize negative log-likelihood using `optim`
# opt <- optim(theta_init, LMMprof, setup = setup, method = "L-BFGS-B", control = list(fnscale = 1))
opt <- optim(theta_init, LMMprof, setup = setup, lower = lower_bounds,
upper = upper_bounds, method = "L-BFGS-B", control = list())
# Extract optimal theta and compute beta estimate
theta_opt <- opt$par
sigma_opt <- exp(theta_opt[1])
psi_diag_opt <- exp(2 * theta_opt[-1])
# # Recompute beta estimate using optimized theta
# #fix this one hac
# W <- chol2inv(chol(qr.R(qr(setup$Z)) %*% diag(psi_diag_opt, ncol(setup$Z), ncol(setup$Z)) %*% t(qr.R(qr(setup$Z))) + sigma_opt^2 * diag(length(setup$y))))
# beta_hat <- solve(t(setup$X) %*% W %*% setup$X, t(setup$X) %*% W %*% setup$y)
return(list(beta = beta_hat, theta = theta_opt))
}
# mtrace(lmm, FALSE)
# mtrace(LMMprof, FALSE)
# Load the Machines dataset and use `lmm` function
data("Machines", package = "nlme")
result <- lmm(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
solve_chol <- function(L, b) {
return (backsolve(L, forwardsolve(t(L),b)))
}
LMMprof <- function(theta, setup) {
# browser()
X <- setup$X
Z <- setup$Z
y <- setup$y
Z_cols<-setup$dimensions
qr_decomp<-setup$qr_decomp
R<-setup$R
# Dimensions
n <- length(y)
p <- ncol(Z)
# Extract sigma and random effects variances from theta
sigma <- exp(theta[1])#I think we don't need to expone
psi_diag <- exp(2 * theta[-1])
# browser()
# Construct the covariance matrix Psi_b for the random effects
Psi_b <- diag(rep(psi_diag, Z_cols), ncol(Z), ncol(Z))
small_block<-R%*%Psi_b%*%t(R)+diag(1, nrow = p, ncol = p)*(sigma^2)
# Cholesky decomposition
small_block_chol <- chol(small_block)
small_block_Inv<-solve_chol(small_block_chol, diag(x = 1, nrow = p, ncol = p))
I_n_p <- diag(n - p)/(sigma^(2))
# Construct the full W matrix
W_middle <- rbind(
cbind(small_block_Inv, matrix(0, nrow = p, ncol = n - p)),
cbind(matrix(0, nrow = n - p, ncol = p), I_n_p)
)
# Calculate W using Q and the block matrix
# W3 <- qr.qy(qr_decomp, t(qr.qy(qr_decomp, t(W_middle))))
# W2<-Q %*% W_middle %*% t(Q)
# Compute log likelihood terms
XWX<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, X)
XWy<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, y)
XWX_chol <- chol(XWX)
beta_hat<-solve_chol(L=XWX_chol, b=XWy)
residual <- y - X %*% beta_hat
minus_log_likelihood<- 0.5*t(residual)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, residual)+sum(log(diag(small_block_Inv)))+ ((n - p) * log(sigma^2)/2)
# log_likelihood <- -0.5 * (t(residual) %*% W %*% residual + sum(log(diag(chol(small_block)))) + (n - p) * log(sigma^2))
print("minus_Log-likelihood:")
print(minus_log_likelihood)
attr(minus_log_likelihood, "beta_hat") <- beta_hat
return(minus_log_likelihood)  # Return negative log-likelihood for minimization
}
lmm <- function(form, dat, ref = list()) {
# Step 1: Setup model matrices and data
setup <- LMMsetup(form, dat, ref)
# QR Decomposition of Z
setup$qr_decomp <- qr(setupZ)
setup$R <- qr.R(setup$qr_decomp)
# Step 2: Initial guesses for theta: log(sigma) and log standard deviations for random effects
theta_init <- rep(0, length(ref) + 1)  # Starting with a small positive value
lower_bounds <- rep(log(0.001), length(ref) + 1)  # Example: ensuring all theta > -2
upper_bounds <- rep(log(100), length(ref) + 1)  # No upper bounds, or set specifically if needed
# Step 3: Optimize negative log-likelihood using `optim`
# opt <- optim(theta_init, LMMprof, setup = setup, method = "L-BFGS-B", control = list(fnscale = 1))
opt <- optim(theta_init, LMMprof, setup = setup, lower = lower_bounds,
upper = upper_bounds, method = "L-BFGS-B", control = list())
LMMprof(theta = opt$par, setup = setup)
final_cost_value <- cost_function(optimized_theta)
# Accessing the attribute "beta"
beta_hat <- attr(final_cost_value, "beta")
return(list(beta = beta_hat, theta = opt$par))
}
# mtrace(lmm, FALSE)
# mtrace(LMMprof, FALSE)
# Load the Machines dataset and use `lmm` function
data("Machines", package = "nlme")
result <- lmm(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
lmm <- function(form, dat, ref = list()) {
# Step 1: Setup model matrices and data
setup <- LMMsetup(form, dat, ref)
# QR Decomposition of Z
setup$qr_decomp <- qr(setup$Z)
setup$R <- qr.R(setup$qr_decomp)
# Step 2: Initial guesses for theta: log(sigma) and log standard deviations for random effects
theta_init <- rep(0, length(ref) + 1)  # Starting with a small positive value
lower_bounds <- rep(log(0.001), length(ref) + 1)  # Example: ensuring all theta > -2
upper_bounds <- rep(log(100), length(ref) + 1)  # No upper bounds, or set specifically if needed
# Step 3: Optimize negative log-likelihood using `optim`
# opt <- optim(theta_init, LMMprof, setup = setup, method = "L-BFGS-B", control = list(fnscale = 1))
opt <- optim(theta_init, LMMprof, setup = setup, lower = lower_bounds,
upper = upper_bounds, method = "L-BFGS-B", control = list())
LMMprof(theta = opt$par, setup = setup)
final_cost_value <- cost_function(optimized_theta)
# Accessing the attribute "beta"
beta_hat <- attr(final_cost_value, "beta")
return(list(beta = beta_hat, theta = opt$par))
}
# mtrace(lmm, FALSE)
# mtrace(LMMprof, FALSE)
# Load the Machines dataset and use `lmm` function
data("Machines", package = "nlme")
result <- lmm(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
LMMsetup <- function(form, dat, ref = list()) {
# Construct fixed effects model matrix (X) from formula and data
X <- model.matrix(form, dat)
# Construct random effects model matrix (Z)
# Z_list <- lapply(ref, function(vars) model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat))
Z_list <- lapply(ref, function(vars) {
# Create the model matrix
model_mat <- model.matrix(as.formula(paste("~", paste(vars, collapse = ":"), "-1")), dat)
# Get the dimensions of the matrix
attr(model_mat, "columns") <- dim(model_mat)[2]
return(model_mat)
})
Z <- do.call(cbind, Z_list)
dimensions<-lapply(Z_list, function(Z) attr(Z, "columns"))
# Response variable
y <- model.response(model.frame(form, dat))
return(list(X = X, Z=Z,y=y, dimensions=dimensions))
}
setup <- LMMsetup(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
solve_chol <- function(L, b) {
return (backsolve(L, forwardsolve(t(L),b)))
}
LMMprof <- function(theta, setup) {
# browser()
X <- setup$X
Z <- setup$Z
y <- setup$y
Z_cols<-setup$dimensions
qr_decomp<-setup$qr_decomp
R<-setup$R
# Dimensions
n <- length(y)
p <- ncol(Z)
# Extract sigma and random effects variances from theta
sigma <- exp(theta[1])#I think we don't need to expone
psi_diag <- exp(2 * theta[-1])
# browser()
# Construct the covariance matrix Psi_b for the random effects
Psi_b <- diag(rep(psi_diag, Z_cols), ncol(Z), ncol(Z))
small_block<-R%*%Psi_b%*%t(R)+diag(1, nrow = p, ncol = p)*(sigma^2)
# Cholesky decomposition
small_block_chol <- chol(small_block)
small_block_Inv<-solve_chol(small_block_chol, diag(x = 1, nrow = p, ncol = p))
I_n_p <- diag(n - p)/(sigma^(2))
# Construct the full W matrix
W_middle <- rbind(
cbind(small_block_Inv, matrix(0, nrow = p, ncol = n - p)),
cbind(matrix(0, nrow = n - p, ncol = p), I_n_p)
)
# Calculate W using Q and the block matrix
# W3 <- qr.qy(qr_decomp, t(qr.qy(qr_decomp, t(W_middle))))
# W2<-Q %*% W_middle %*% t(Q)
# Compute log likelihood terms
XWX<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, X)
XWy<-t(X)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, y)
XWX_chol <- chol(XWX)
beta_hat<-solve_chol(L=XWX_chol, b=XWy)
residual <- y - X %*% beta_hat
minus_log_likelihood<- 0.5*t(residual)%*%qr.qy(qr_decomp, W_middle)%*%qr.qty(qr_decomp, residual)+sum(log(diag(small_block_Inv)))+ ((n - p) * log(sigma^2)/2)
# log_likelihood <- -0.5 * (t(residual) %*% W %*% residual + sum(log(diag(chol(small_block)))) + (n - p) * log(sigma^2))
print("minus_Log-likelihood:")
print(minus_log_likelihood)
attr(minus_log_likelihood, "beta_hat") <- beta_hat
return(minus_log_likelihood)  # Return negative log-likelihood for minimization
}
lmm <- function(form, dat, ref = list()) {
# Step 1: Setup model matrices and data
setup <- LMMsetup(form, dat, ref)
# QR Decomposition of Z
setup$qr_decomp <- qr(setup$Z)
setup$R <- qr.R(setup$qr_decomp)
# Step 2: Initial guesses for theta: log(sigma) and log standard deviations for random effects
theta_init <- rep(0, length(ref) + 1)  # Starting with a small positive value
lower_bounds <- rep(log(0.001), length(ref) + 1)  # Example: ensuring all theta > -2
upper_bounds <- rep(log(100), length(ref) + 1)  # No upper bounds, or set specifically if needed
# Step 3: Optimize negative log-likelihood using `optim`
# opt <- optim(theta_init, LMMprof, setup = setup, method = "L-BFGS-B", control = list(fnscale = 1))
opt <- optim(theta_init, LMMprof, setup = setup, lower = lower_bounds,
upper = upper_bounds, method = "L-BFGS-B", control = list())
final_cost_value <- LMMprof(theta = opt$par, setup = setup)
# Accessing the attribute "beta"
beta_hat <- attr(final_cost_value, "beta")
return(list(beta = beta_hat, theta = opt$par))
}
# mtrace(lmm, FALSE)
# mtrace(LMMprof, FALSE)
# Load the Machines dataset and use `lmm` function
data("Machines", package = "nlme")
result <- lmm(score ~ Machine, dat = Machines, ref = list("Worker", c("Worker", "Machine")))
result$beta
